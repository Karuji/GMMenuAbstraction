<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// ReadMe.txt

/*

The basic theory of the menu abstration is that menu items should not be running game code
themselves and that they should just be used as graphical placements for the item.

This system is designed for systems that use keyboard or controller input.
The collision system of a mouse is out of scope for the intended code in this system.

The system makes an assumption that a menu item may independantly decide if it needs to 
exist in its create event and the menu will deal with the result of such decisions.
This is important since some menu items may depend on a global game state.

*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// ParMenu Create

menu = ds_grid_create(0,2);

// Start pos is the menu item that will be selected when the menu is activated.
// it runs from 0 to ds_grid_width( menu) -1.
startPos = 0;

// Has Focus is for when there are (sub)menues in menus.
// It is used to determine which part of the menu system will react to input.
has_focus = id;

// Has general focus is used to determine if a parent menu, or one of its child menus
// currently has focus.
has_general_focus = true;

// Parent menu is for when a menu is a sub menu.
// It serves the dual purpose of determining when a menu is the root.
//     |-&gt; This is when "parent_menu = id"
// And providing a reference to a parent to return focus to.
parent_menu = id;

// Enabled is for when a menu object exists, but you do not want it
// to run its step event code.
enabled = true;

// Generic references to scripts for moving the position of the menu Pos.
// This is so that you can easily tie MenuAbstraction into your input system
// It's also useful since you might need menus which move vertically or horizonatally.
get_next = menu_get_down;
get_prev = menu_get_up;

// Generic script refs to escape and return.
// Same reason as previous and next above.
get_return = menu_get_return;
get_escape = menu_get_escape;
get_destoy = menu_get_destroy;

// When destroy_menu_items is set to true it will destroy the
// the instances in menu in addition to the datastructure itself.
destroy_menu_items = true;

// This is to allow the root menu to call it's destroy and related functions.
// Would be used if you are paused and want to maintain a single button to exit
// the menu and unpause the game.
root_can_destoy = true;

// Selected is ONLY for sub menus.
// Selected here serves the same purpose as in the menu_item:
// to enable the object to handle a graphic representation that the parent menu
// is currently focusing on it.
selected = false;

// This is a variable to make a sub menu be actionable without having to select the menu
// itself. This is to be used when a parent menu uses vertical inputs, and the child
// menu uses horizontal inputs so the user doesn't have to enter and return.
select_is_focus = false;

// Auto_next_enabled will traverse the menu item until if finds the next
// menu item that is enabled.
// Menu items that are not enabled will not run their attatched script.
auto_next_enabled = true;

// This enables the wraping of focus of menu items.
// It's not really something that should ever be changed via code.
// And I'm just putting it here since I believe that most settings should
// be done in the create even so that step events are purely inherited.
can_wrap = true;

// ===========================================================================
// ===========================BACK END VARIABLES==============================
// ===========================================================================

// The following variables are used by the class for automated functions,
// and should not be changed.
lose_focus = false;
// Actionable needs to be false since we need to ignore the first frame when a menu
// can be created since with pause menus it is likely the same key to exit them.
actionable = false;
delta_pos  = 1;
Pos = 0;
Pos_previous = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if( destroy_menu_items)
{
    if( ds_exists( menu, ds_type_grid))
    {
        // Destroy contents of the DataStructure.
        for( var _i = 0; _i &lt; ds_grid_width( menu); _i++)
        {
            var _item = menu[# _i, 0].id;
            if( instance_exists( _item))
            {
                with( _item)
                {
                    instance_destroy();
                }
            }
        }
    }
}

if( ds_exists( menu, ds_type_grid))
{
    // Actually the desroy the DataStructure.
    ds_grid_destroy( menu);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if( lose_focus)
{
    has_focus = 0;
    lose_focus = false;
}

if( !actionable)
{
    actionable = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// select_is_focus is only to be used on a submenu.
// The submenu MUST have different input methods to its parent.
if( select_is_focus)
{
    if( selected &amp;&amp; parent_menu.has_focus == parent_menu.id)
    {
        has_focus = id;
        has_general_focus = true;
    }
    else
    {
        has_focus = 0;
        has_general_focus = false;
    }
    
    if( !parent_menu.actionable)
    {
        actionable = false;
    }
}

if( parent_menu == id &amp;&amp; root_can_destoy 
    &amp;&amp; has_general_focus &amp;&amp; actionable &amp;&amp; enabled)
{
    if( script_execute( menu_get_destroy))
    {
        event_user( 1);
        exit;
    }
}

// Menus should only operate if they currently have focus.  
if( has_focus == id &amp;&amp; actionable &amp;&amp; enabled)
{
    // Escape the current menu system.
    // This cannot be called if !select_is_focus since the parent menu already has focus.
    if( script_execute( get_escape) &amp;&amp; !select_is_focus)
    {
        // If the current menu system is a submenu then we return focus to the parent.
        if( parent_menu != id)
        {
            has_focus = parent_menu;
            has_general_focus = false;
            parent_menu.has_focus = parent_menu;
            exit;
        }
        else
        {
            // I really don't know what the case of returning from a main menu in
            // a variety of games could be, but it will call the User Defined 0.
            event_user( 0);
            exit;
        }
    }  
    
    
    // Operations on the menu should only be performed if there are items in the menu.
    if( ds_grid_width( menu) &gt; 0)
    {
        // Check inputs for movement in a menu.
        // This is placeholder and I'm assuming you have your own method of handling input
        // in the game that will replace this.
        Pos += script_execute( get_next);
        Pos -= script_execute( get_prev);    
    
        // Check that the current item is enabled.
        // If it's not we go to the next enabled item.
        delta_pos = 0;
        if( Pos != Pos_previous)
        {
            var count = 0;
            var relative = 0;
            
            if( Pos + delta_pos &gt; ds_grid_width( menu)-1)
            {
                relative -= ds_grid_width( menu);
            }
            if( Pos + delta_pos &lt; 0)
            {
                relative += ds_grid_width( menu);
            }
            
            while( menu[# Pos + delta_pos + relative, 0].enabled == false &amp;&amp; auto_next_enabled)
            {
                ++count;
                if( count &gt;= ds_grid_width( menu))
                {
                    show_error( object_get_name(id) + " has no enabled menu items.", true);
                } 
                
                delta_pos += sign(Pos - Pos_previous);
            }
            
            Pos += delta_pos;
        }
        
        // This is to wrap the position of the the focus.
        if( can_wrap)
        {
            if( Pos &lt; 0)
            {
                Pos += ds_grid_width( menu);
            }         
            if( Pos &gt; ds_grid_width( menu) -1)
            {
                Pos -= ds_grid_width( menu);
            }
        }
        // Or hold pos if there is no wrapping.
        else
        {
            if( Pos &lt; 0)
            {
                Pos = Pos_previous;
            }
            if( Pos &gt; ds_grid_width( menu) -1)
            {
                Pos = Pos_previous;
            }
        }    
        
        if( Pos != Pos_previous)
        {
            menu[# Pos_previous, 0].selected = false;
            menu[# Pos, 0].selected = true;
            Pos_previous = Pos;
            actionable = false;
            exit;
        }
    
        // Check if the user is confirming use of an item, or
        // selection of a submenu.
        if( script_execute( get_return))
        {
            if( menu[# Pos, 0].enabled == true)
            {         
                // If the selected item is a menu we shift focus to that menu.
                if( object_is_ancestor( menu[# Pos, 0].object_index, par_menu))
                {
                    // Check is a submenu's select_is_focus is false.
                    // There is no need to move focus to it if it is true,
                    // as it already has focus.
                    var _submenu = menu[# Pos, 0]
                    if( !_submenu.select_is_focus)
                    {
                        with( _submenu)
                        {
                            has_focus = id;
                            has_general_focus = true;
                            actionable = false;
                            other.has_focus = id;
                            other.actionable = false;
                        }
                    }
                }
        
                // If the selected item is an item: execute its script.
                if( object_is_ancestor( menu[# Pos, 0].object_index, par_menu_item))
                {
                    script_execute( menu[# Pos, 1], menu[# Pos, 0], id);
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Dear Julian: we're using 15 'cause a bunch of menus are using things in the 0-5 range,
// when you put this into the public stuff this should be ev_user1.

// Instance destroy is called here instead of in the step event since it might not
// always be desirable to destroy the object.
// This leaves the option to not call event_inherited in the child menu so it won't
// be destroyed at this time.
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Called when escaping and the root menu has focus.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
We use room start for this code since the inherited event of the object ends in the create,
and the user will be adding the menu items after the event_inherited() {else they add to
nothing} so the room start will process the data inputed automatically for the user.
*/

if( ds_exists( menu, ds_type_grid))
{
    var _width = ds_grid_width( menu);
    
    if( _width &gt; 0)
    {
        if( startPos &lt; 0 || startPos &gt; _width -1)
        {
            startPos = 0;
        }
        
        menu[# startPos, 0].selected = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
