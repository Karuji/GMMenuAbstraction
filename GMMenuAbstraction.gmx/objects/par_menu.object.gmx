<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// ReadMe.txt

/*

The basic theory of the menu abstration is that menu items should not be running game code
themselves and that they should just be used as graphical placements for the item.

This system is designed for systems that use keyboard or controller input.
The collision system of a mouse is out of scope for the intended code in this system.

The system makes an assumption that a menu item may independantly decide if it needs to 
exist in its create event and the menu will deal with the result of such decisions.
This is important since some menu items may depend on a global game state.

*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// ParMenu Create

menu = ds_grid_create(0,2);

// Start pos is the menu item that will be selected when the menu is activated.
// it runs from 0 to ds_grid_width( menu) -1.
startPos = 0;

Pos = 0;
Pos_previous = 0;

// Has Focus is for when there are (sub)menues in menus.
// It is used to determine which part of the menu system will react to input.
has_focus = id;

// Parent menu is for when a menu is a sub menu.
// It serves the dual purpose of determining when a menu is the root.
//     |-&gt; This is when "parent_menu = id"
// And providing a reference to a parent to return focus to.
parent_menu = id;

// Selected is ONLY for sub menus.
// Selected here serves the same purpose as in the menu_item:
// to enable the object to handle a graphic representation that the parent menu
// is currently focusing on it.
selected = false;

// This enables the wraping of focus of menu items.
// It's not really something that should ever be changed via code.
// And I'm just putting it here since I believe that most settings should
// be done in the create even so that step events are purely inherited.
can_wrap = true;

lose_focus = false;
actionable = true;

show_debug_message("Create");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if( ds_exists( menu, ds_type_grid))
{
    ds_grid_destroy( menu);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if( lose_focus)
{
    has_focus = 0;
    lose_focus = false;
}

if( !actionable)
{
    actionable = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Menus should only operate if they currently have focus.
if( has_focus == id &amp;&amp; actionable)
{
    // Escape the current menu system.
    if( keyboard_check_pressed( vk_escape))
    {
        // If the current menu system is a submenu then we return focus to the parent.
        if( parent_menu != id)
        {
            has_focus = parent_menu;
            parent_menu.has_focus = parent_menu;
        }
        else
        {
            // I really don't know what the case of returning from a main menu in
            // a variety of games could be, but it would go here.
        }
    }
    
    // Check inputs for movement in a menu.
    // This is placeholder and I'm assuming you have your own method of handling input
    // in the game that will replace this.
    Pos += keyboard_check_pressed( vk_down);
    Pos -= keyboard_check_pressed( vk_up);
    
    // This is to wrap the position of the the focus.
    if( can_wrap)
    {
        if( Pos &lt; 0)
        {
            Pos = ds_grid_width( menu) -1;
        }        
        if( Pos &gt; ds_grid_width( menu) -1)
        {
            Pos = 0;
        }
    }
    
    // Changing the current menu item that is being highlighted.
    if( Pos != Pos_previous)
    {
        menu[# Pos_previous, 0].selected = false;
        menu[# Pos, 0].selected = true;
        Pos_previous = Pos;
    }
    
    // Check if the user is confirming use of an item, or
    // selection of a submenu.
    if( keyboard_check_pressed( vk_enter))
    {         
        // If the selected item is a menu we shift focus to that menu.
        if( object_is_ancestor( menu[# Pos, 0].object_index, par_menu))
        {
            with( menu[# Pos, 0])
            {
                has_focus = id;
                actionable = false;
                other.has_focus = id;
                other.actionable = false;
            }

        }

        // If the selected item is an item: execute its script.
        if( object_is_ancestor( menu[# Pos, 0].object_index, par_menu_item))
        {
            script_execute( menu[# Pos, 1]);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
We use room start for this code since the inherited event of the object ends in the create,
and the user will be adding the menu items after the event_inherited() {else they add to
nothing} so the room start will process the data inputed automatically for the user.
*/

if( ds_exists( menu, ds_type_grid))
{
    var _width = ds_grid_width( menu);
    
    if( _width &gt; 0)
    {
        if( startPos &lt; 0 || startPos &gt; _width -1)
        {
            startPos = 0;
        }
        
        menu[# startPos, 0].selected = true;
    }
    
    show_debug_message("Room Start");
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
